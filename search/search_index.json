{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to gtlparser","text":"<p>A python package for Google Time Line data analysis</p> <ul> <li>Free software: MIT License</li> <li>Documentation: https://GGweelplay.github.io/gtlparser</li> </ul>"},{"location":"#introduction","title":"Introduction","text":"<p>The gtlparser addresses the challenge of converting raw location data downloaded from Google Timeline into a standardized and easily usable format for spatial analysis and visualization. Google Timeline provides a rich source of spatiotemporal information, capturing detailed latitude, longitude, and timestamp data of a user's movements. However, the native JSON format can be cumbersome to work with directly in many geospatial tools.</p> <p>This package provides a convenient solution by transforming the Google Timeline JSON data into the GeoJSON format. GeoJSON is a widely supported standard for encoding geographic data structures, making it ideal for representing trajectories and points of interest. By converting your timeline data to GeoJSON, you can seamlessly integrate it with various mapping and Geographic Information System (GIS) software, enabling you to visualize your space-time trajectory, perform spatial analysis, and gain insights from your location history.</p>"},{"location":"#target-audience","title":"Target Audience","text":"<p>This package is designed for researchers, data analysts, educators, and individuals who wish to explore, visualize, and analyze their personal Google Timeline data using standard geospatial tools.</p>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#v001-date","title":"v0.0.1 - Date","text":"<p>Improvement:</p> <ul> <li>TBD</li> </ul> <p>New Features:</p> <ul> <li>TBD</li> </ul>"},{"location":"common/","title":"common module","text":"<p>The common module contains common functions and classes used by the other modules.</p>"},{"location":"common/#gtlparser.common.hello_world","title":"<code>hello_world()</code>","text":"<p>Prints \"Hello World!\" to the console.</p> Source code in <code>gtlparser/common.py</code> <pre><code>def hello_world():\n    \"\"\"Prints \"Hello World!\" to the console.\"\"\"\n    print(\"Hello World!\")\n</code></pre>"},{"location":"contributing/","title":"Contributing","text":"<p>Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.</p> <p>You can contribute in many ways:</p>"},{"location":"contributing/#types-of-contributions","title":"Types of Contributions","text":""},{"location":"contributing/#report-bugs","title":"Report Bugs","text":"<p>Report bugs at https://github.com/GGweelplay/gtlparser/issues.</p> <p>If you are reporting a bug, please include:</p> <ul> <li>Your operating system name and version.</li> <li>Any details about your local setup that might be helpful in troubleshooting.</li> <li>Detailed steps to reproduce the bug.</li> </ul>"},{"location":"contributing/#fix-bugs","title":"Fix Bugs","text":"<p>Look through the GitHub issues for bugs. Anything tagged with <code>bug</code> and <code>help wanted</code> is open to whoever wants to implement it.</p>"},{"location":"contributing/#implement-features","title":"Implement Features","text":"<p>Look through the GitHub issues for features. Anything tagged with <code>enhancement</code> and <code>help wanted</code> is open to whoever wants to implement it.</p>"},{"location":"contributing/#write-documentation","title":"Write Documentation","text":"<p>gtlparser could always use more documentation, whether as part of the official gtlparser docs, in docstrings, or even on the web in blog posts, articles, and such.</p>"},{"location":"contributing/#submit-feedback","title":"Submit Feedback","text":"<p>The best way to send feedback is to file an issue at https://github.com/GGweelplay/gtlparser/issues.</p> <p>If you are proposing a feature:</p> <ul> <li>Explain in detail how it would work.</li> <li>Keep the scope as narrow as possible, to make it easier to implement.</li> <li>Remember that this is a volunteer-driven project, and that contributions are welcome :)</li> </ul>"},{"location":"contributing/#get-started","title":"Get Started!","text":"<p>Ready to contribute? Here's how to set up gtlparser for local development.</p> <ol> <li> <p>Fork the gtlparser repo on GitHub.</p> </li> <li> <p>Clone your fork locally:</p> <pre><code>$ git clone git@github.com:your_name_here/gtlparser.git\n</code></pre> </li> <li> <p>Install your local copy into a virtualenv. Assuming you have     virtualenvwrapper installed, this is how you set up your fork for     local development:</p> <pre><code>$ mkvirtualenv gtlparser\n$ cd gtlparser/\n$ python setup.py develop\n</code></pre> </li> <li> <p>Create a branch for local development:</p> <pre><code>$ git checkout -b name-of-your-bugfix-or-feature\n</code></pre> <p>Now you can make your changes locally.</p> </li> <li> <p>When you're done making changes, check that your changes pass flake8     and the tests, including testing other Python versions with tox:</p> <pre><code>$ flake8 gtlparser tests\n$ python setup.py test or pytest\n$ tox\n</code></pre> <p>To get flake8 and tox, just pip install them into your virtualenv.</p> </li> <li> <p>Commit your changes and push your branch to GitHub:</p> <pre><code>$ git add .\n$ git commit -m \"Your detailed description of your changes.\"\n$ git push origin name-of-your-bugfix-or-feature\n</code></pre> </li> <li> <p>Submit a pull request through the GitHub website.</p> </li> </ol>"},{"location":"contributing/#pull-request-guidelines","title":"Pull Request Guidelines","text":"<p>Before you submit a pull request, check that it meets these guidelines:</p> <ol> <li>The pull request should include tests.</li> <li>If the pull request adds functionality, the docs should be updated.     Put your new functionality into a function with a docstring, and add     the feature to the list in README.rst.</li> <li>The pull request should work for Python 3.8 and later, and     for PyPy. Check https://github.com/GGweelplay/gtlparser/pull_requests and make sure that the tests pass for all     supported Python versions.</li> </ol>"},{"location":"faq/","title":"FAQ","text":""},{"location":"foliumap/","title":"foliumap module","text":"<p>This module provides a custom Map class that extends folium.Map</p>"},{"location":"foliumap/#gtlparser.foliumap.Map","title":"<code> Map            (Map)         </code>","text":"<p>A custom Map class that inherits from folium.Map and adds additional functionalities for basemap support, layer control, and vector data handling.</p> Source code in <code>gtlparser/foliumap.py</code> <pre><code>class Map(folium.Map):\n    \"\"\"\n    A custom Map class that inherits from folium.Map and adds additional\n    functionalities for basemap support, layer control, and vector data handling.\n    \"\"\"\n\n    def __init__(self, location=[20, 0], zoom_start=2, **kwargs):\n        \"\"\"\n        Initializes the Map object, inherits from folium.Map.\n\n        Args:\n            location (list): Initial location of the map [latitude, longitude].\n            zoom_start (int): Initial zoom level of the map.\n            **kwargs: Additional keyword arguments to pass to folium.Map.\n        \"\"\"\n        super().__init__(location=location, zoom_start=zoom_start, **kwargs)\n\n    def add_basemap(self, basemap=\"OpenStreetMap\"):\n        \"\"\"\n        Adds a basemap to the map.\n\n        Args:\n            basemap_name (str): The name of the basemap to be added.\n                Examples: 'OpenStreetMap', 'Esri.WorldImagery', 'OpenTopoMap'.\n\n        Returns:\n            None: Adds the basemap to the map.\n        \"\"\"\n        folium.TileLayer(basemap).add_to(self)\n\n    def add_vector(self, data, **kwargs):\n        \"\"\"\n        Adds vector data (GeoJSON/Shapefile) to the map.\n\n        Args:\n            data (str or GeoDataFrame): The vector data to be added to the map.\n                Can be a file path (str) or a GeoDataFrame.\n            **kwargs: Additional keyword arguments for the GeoJSON layer.\n\n        Raises:\n            ValueError: If the data type is invalid.\n        \"\"\"\n        import geopandas as gpd\n\n        if isinstance(data, str):\n            gdf = gpd.read_file(data)\n            self.add_gdf(gdf, **kwargs)\n        elif isinstance(data, gpd.GeoDataFrame):\n            self.add_gdf(data, **kwargs)\n        elif isinstance(data, dict):\n            self.add_geojson(data, **kwargs)\n        else:\n            raise ValueError(\"Invalid data type.\")\n\n    def add_layer_control(self):\n        \"\"\"\n        Adds a layer control widget to the map to manage different layers.\n\n        Args:\n            None\n\n        Returns:\n            None: Adds a layer control widget to the map.\n        \"\"\"\n        folium.LayerControl().add_to(self)\n\n    def add_geojson(self, data, **kwargs):\n        \"\"\"\n        Adds GeoJSON data to the map.\n\n        Args:\n            data (str or dict): The GeoJson data. Can be a file path (str) or a dictionary.\n            **kwargs: Additinoal keyword arguments for the ipyleaflet.GeoJSON layer.\n\n        Raises:\n            ValueError: If the data type is invalid\n        \"\"\"\n        import geopandas as gpd\n\n        if isinstance(data, str):\n            gdf = gpd.read_file(data)\n            geojson = gdf.__geo_interface__\n        elif isinstance(data, dict):\n            geojson = data\n\n        geojson = folium.GeoJson(data=geojson, **kwargs)\n        geojson.add_to(self)\n\n    def add_shp(self, data, **kwargs):\n        \"\"\"\n        Adds shapefile data to the map.\n\n        Args:\n            data (str): The path to the shapefile.\n            **kwargs: Additional keyword arguments for folium.GeoJson.\n\n        Returns:\n            None: Adds the shapefile data to the map.\n        \"\"\"\n        import geopandas as gpd\n\n        gdf = gpd.read_file(data)\n        gdf = gdf.to_crs(epsg=4326)\n        geojson = gdf.__geo_interface__\n        self.add_geojson(geojson, **kwargs)\n\n    def add_gdf(self, gdf, **kwargs):\n        \"\"\"\n        Adds a GeoDataFrame to the map.\n\n        Args:\n            gdf (GeoDataFrame): The GeoDataFrame to be added to the map.\n            **kwargs: Additional keyword arguments for folium.GeoJson.\n\n        Returns:\n            None: Adds the GeoDataFrame to the map.\n        \"\"\"\n        gdf = gdf.to_crs(epsg=4326)\n        geojson = gdf.__geo_interface__\n        self.add_geojson(geojson, **kwargs)\n\n    def add_split_map(self, left=\"openstreetmap\", right=\"cartodbpositron\", **kwargs):\n        \"\"\"\n        Adds a split map to the map.\n\n        Args:\n            left (folium.Map): The left map to be added.\n            right (folium.Map): The right map to be added.\n            **kwargs: Additional keyword arguments for folium.SplitMap.\n\n        Returns:\n            None: Adds the split map to the map.\n        \"\"\"\n\n        # Directly pass the 'left' and 'right' arguments (URLs or file paths)\n        # to get_leaflet_tile_layer\n\n        import os\n        from localtileserver import get_folium_tile_layer\n        import folium\n        from folium import plugins\n\n        if left.startswith(\"http\") or os.path.exists(left):\n            layer_left = get_folium_tile_layer(left, **kwargs)\n        else:\n            layer_left = folium.TileLayer(left, overlay=True, **kwargs)\n\n        if right.startswith(\"http\") or os.path.exists(right):\n            layer_right = get_folium_tile_layer(right, **kwargs)\n        else:\n            layer_right = folium.TileLayer(right, overlay=True, **kwargs)\n\n        sbs = folium = plugins.SideBySideLayers(\n            layer_left=layer_left, layer_right=layer_right\n        )\n\n        layer_left.add_to(self)\n        layer_right.add_to(self)\n        sbs.add_to(self)\n</code></pre>"},{"location":"foliumap/#gtlparser.foliumap.Map.__init__","title":"<code>__init__(self, location=[20, 0], zoom_start=2, **kwargs)</code>  <code>special</code>","text":"<p>Initializes the Map object, inherits from folium.Map.</p> <p>Parameters:</p> Name Type Description Default <code>location</code> <code>list</code> <p>Initial location of the map [latitude, longitude].</p> <code>[20, 0]</code> <code>zoom_start</code> <code>int</code> <p>Initial zoom level of the map.</p> <code>2</code> <code>**kwargs</code> <p>Additional keyword arguments to pass to folium.Map.</p> <code>{}</code> Source code in <code>gtlparser/foliumap.py</code> <pre><code>def __init__(self, location=[20, 0], zoom_start=2, **kwargs):\n    \"\"\"\n    Initializes the Map object, inherits from folium.Map.\n\n    Args:\n        location (list): Initial location of the map [latitude, longitude].\n        zoom_start (int): Initial zoom level of the map.\n        **kwargs: Additional keyword arguments to pass to folium.Map.\n    \"\"\"\n    super().__init__(location=location, zoom_start=zoom_start, **kwargs)\n</code></pre>"},{"location":"foliumap/#gtlparser.foliumap.Map.add_basemap","title":"<code>add_basemap(self, basemap='OpenStreetMap')</code>","text":"<p>Adds a basemap to the map.</p> <p>Parameters:</p> Name Type Description Default <code>basemap_name</code> <code>str</code> <p>The name of the basemap to be added. Examples: 'OpenStreetMap', 'Esri.WorldImagery', 'OpenTopoMap'.</p> required <p>Returns:</p> Type Description <code>None</code> <p>Adds the basemap to the map.</p> Source code in <code>gtlparser/foliumap.py</code> <pre><code>def add_basemap(self, basemap=\"OpenStreetMap\"):\n    \"\"\"\n    Adds a basemap to the map.\n\n    Args:\n        basemap_name (str): The name of the basemap to be added.\n            Examples: 'OpenStreetMap', 'Esri.WorldImagery', 'OpenTopoMap'.\n\n    Returns:\n        None: Adds the basemap to the map.\n    \"\"\"\n    folium.TileLayer(basemap).add_to(self)\n</code></pre>"},{"location":"foliumap/#gtlparser.foliumap.Map.add_gdf","title":"<code>add_gdf(self, gdf, **kwargs)</code>","text":"<p>Adds a GeoDataFrame to the map.</p> <p>Parameters:</p> Name Type Description Default <code>gdf</code> <code>GeoDataFrame</code> <p>The GeoDataFrame to be added to the map.</p> required <code>**kwargs</code> <p>Additional keyword arguments for folium.GeoJson.</p> <code>{}</code> <p>Returns:</p> Type Description <code>None</code> <p>Adds the GeoDataFrame to the map.</p> Source code in <code>gtlparser/foliumap.py</code> <pre><code>def add_gdf(self, gdf, **kwargs):\n    \"\"\"\n    Adds a GeoDataFrame to the map.\n\n    Args:\n        gdf (GeoDataFrame): The GeoDataFrame to be added to the map.\n        **kwargs: Additional keyword arguments for folium.GeoJson.\n\n    Returns:\n        None: Adds the GeoDataFrame to the map.\n    \"\"\"\n    gdf = gdf.to_crs(epsg=4326)\n    geojson = gdf.__geo_interface__\n    self.add_geojson(geojson, **kwargs)\n</code></pre>"},{"location":"foliumap/#gtlparser.foliumap.Map.add_geojson","title":"<code>add_geojson(self, data, **kwargs)</code>","text":"<p>Adds GeoJSON data to the map.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str or dict</code> <p>The GeoJson data. Can be a file path (str) or a dictionary.</p> required <code>**kwargs</code> <p>Additinoal keyword arguments for the ipyleaflet.GeoJSON layer.</p> <code>{}</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the data type is invalid</p> Source code in <code>gtlparser/foliumap.py</code> <pre><code>def add_geojson(self, data, **kwargs):\n    \"\"\"\n    Adds GeoJSON data to the map.\n\n    Args:\n        data (str or dict): The GeoJson data. Can be a file path (str) or a dictionary.\n        **kwargs: Additinoal keyword arguments for the ipyleaflet.GeoJSON layer.\n\n    Raises:\n        ValueError: If the data type is invalid\n    \"\"\"\n    import geopandas as gpd\n\n    if isinstance(data, str):\n        gdf = gpd.read_file(data)\n        geojson = gdf.__geo_interface__\n    elif isinstance(data, dict):\n        geojson = data\n\n    geojson = folium.GeoJson(data=geojson, **kwargs)\n    geojson.add_to(self)\n</code></pre>"},{"location":"foliumap/#gtlparser.foliumap.Map.add_layer_control","title":"<code>add_layer_control(self)</code>","text":"<p>Adds a layer control widget to the map to manage different layers.</p> <p>Returns:</p> Type Description <code>None</code> <p>Adds a layer control widget to the map.</p> Source code in <code>gtlparser/foliumap.py</code> <pre><code>def add_layer_control(self):\n    \"\"\"\n    Adds a layer control widget to the map to manage different layers.\n\n    Args:\n        None\n\n    Returns:\n        None: Adds a layer control widget to the map.\n    \"\"\"\n    folium.LayerControl().add_to(self)\n</code></pre>"},{"location":"foliumap/#gtlparser.foliumap.Map.add_shp","title":"<code>add_shp(self, data, **kwargs)</code>","text":"<p>Adds shapefile data to the map.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str</code> <p>The path to the shapefile.</p> required <code>**kwargs</code> <p>Additional keyword arguments for folium.GeoJson.</p> <code>{}</code> <p>Returns:</p> Type Description <code>None</code> <p>Adds the shapefile data to the map.</p> Source code in <code>gtlparser/foliumap.py</code> <pre><code>def add_shp(self, data, **kwargs):\n    \"\"\"\n    Adds shapefile data to the map.\n\n    Args:\n        data (str): The path to the shapefile.\n        **kwargs: Additional keyword arguments for folium.GeoJson.\n\n    Returns:\n        None: Adds the shapefile data to the map.\n    \"\"\"\n    import geopandas as gpd\n\n    gdf = gpd.read_file(data)\n    gdf = gdf.to_crs(epsg=4326)\n    geojson = gdf.__geo_interface__\n    self.add_geojson(geojson, **kwargs)\n</code></pre>"},{"location":"foliumap/#gtlparser.foliumap.Map.add_split_map","title":"<code>add_split_map(self, left='openstreetmap', right='cartodbpositron', **kwargs)</code>","text":"<p>Adds a split map to the map.</p> <p>Parameters:</p> Name Type Description Default <code>left</code> <code>folium.Map</code> <p>The left map to be added.</p> <code>'openstreetmap'</code> <code>right</code> <code>folium.Map</code> <p>The right map to be added.</p> <code>'cartodbpositron'</code> <code>**kwargs</code> <p>Additional keyword arguments for folium.SplitMap.</p> <code>{}</code> <p>Returns:</p> Type Description <code>None</code> <p>Adds the split map to the map.</p> Source code in <code>gtlparser/foliumap.py</code> <pre><code>def add_split_map(self, left=\"openstreetmap\", right=\"cartodbpositron\", **kwargs):\n    \"\"\"\n    Adds a split map to the map.\n\n    Args:\n        left (folium.Map): The left map to be added.\n        right (folium.Map): The right map to be added.\n        **kwargs: Additional keyword arguments for folium.SplitMap.\n\n    Returns:\n        None: Adds the split map to the map.\n    \"\"\"\n\n    # Directly pass the 'left' and 'right' arguments (URLs or file paths)\n    # to get_leaflet_tile_layer\n\n    import os\n    from localtileserver import get_folium_tile_layer\n    import folium\n    from folium import plugins\n\n    if left.startswith(\"http\") or os.path.exists(left):\n        layer_left = get_folium_tile_layer(left, **kwargs)\n    else:\n        layer_left = folium.TileLayer(left, overlay=True, **kwargs)\n\n    if right.startswith(\"http\") or os.path.exists(right):\n        layer_right = get_folium_tile_layer(right, **kwargs)\n    else:\n        layer_right = folium.TileLayer(right, overlay=True, **kwargs)\n\n    sbs = folium = plugins.SideBySideLayers(\n        layer_left=layer_left, layer_right=layer_right\n    )\n\n    layer_left.add_to(self)\n    layer_right.add_to(self)\n    sbs.add_to(self)\n</code></pre>"},{"location":"foliumap/#gtlparser.foliumap.Map.add_vector","title":"<code>add_vector(self, data, **kwargs)</code>","text":"<p>Adds vector data (GeoJSON/Shapefile) to the map.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str or GeoDataFrame</code> <p>The vector data to be added to the map. Can be a file path (str) or a GeoDataFrame.</p> required <code>**kwargs</code> <p>Additional keyword arguments for the GeoJSON layer.</p> <code>{}</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the data type is invalid.</p> Source code in <code>gtlparser/foliumap.py</code> <pre><code>def add_vector(self, data, **kwargs):\n    \"\"\"\n    Adds vector data (GeoJSON/Shapefile) to the map.\n\n    Args:\n        data (str or GeoDataFrame): The vector data to be added to the map.\n            Can be a file path (str) or a GeoDataFrame.\n        **kwargs: Additional keyword arguments for the GeoJSON layer.\n\n    Raises:\n        ValueError: If the data type is invalid.\n    \"\"\"\n    import geopandas as gpd\n\n    if isinstance(data, str):\n        gdf = gpd.read_file(data)\n        self.add_gdf(gdf, **kwargs)\n    elif isinstance(data, gpd.GeoDataFrame):\n        self.add_gdf(data, **kwargs)\n    elif isinstance(data, dict):\n        self.add_geojson(data, **kwargs)\n    else:\n        raise ValueError(\"Invalid data type.\")\n</code></pre>"},{"location":"gtl2geojson/","title":"gtl2geojson module","text":""},{"location":"gtl2geojson/#gtlparser.gtl2geojson.create_geojson_file","title":"<code>create_geojson_file(output_path, output_name, feature_collection, flag_point=True)</code>","text":"<p>Create a GeoJSON file from the feature collection.</p> <p>Parameters:</p> Name Type Description Default <code>output_path</code> <code>str</code> <p>The path where the GeoJSON file will be saved.</p> required <code>output_name</code> <code>str</code> <p>The name of the output GeoJSON file.</p> required <code>feature_collection</code> <code>FeatureCollection</code> <p>The feature collection to be saved.</p> required <code>flag_point</code> <code>bool</code> <p>Flag to indicate whether the features are points or lines.</p> <code>True</code> <p>Returns:</p> Type Description <p>None</p> Source code in <code>gtlparser/gtl2geojson.py</code> <pre><code>def create_geojson_file(output_path, output_name, feature_collection, flag_point=True):\n    \"\"\"\n    Create a GeoJSON file from the feature collection.\n\n    Args:\n        output_path (str): The path where the GeoJSON file will be saved.\n        output_name (str): The name of the output GeoJSON file.\n        feature_collection (FeatureCollection): The feature collection to be saved.\n        flag_point (bool): Flag to indicate whether the features are points or lines.\n\n    Returns:\n        None\n    \"\"\"\n    if flag_point:\n        with open(f\"{output_path}/point_{output_name}.geojson\", \"w\") as f:\n            dump(feature_collection, f)\n    else:\n        with open(f\"{output_path}/line_{output_name}.geojson\", \"w\") as f:\n            dump(feature_collection, f)\n</code></pre>"},{"location":"gtl2geojson/#gtlparser.gtl2geojson.parse_hierarchyLevel","title":"<code>parse_hierarchyLevel(subset_visit)</code>","text":"<p>Parse the hierarchy level from the subset_visit dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>subset_visit</code> <code>dict</code> <p>The subset visit dictionary containing the hierarchy level.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The hierarchy level of the visit.</p> Source code in <code>gtlparser/gtl2geojson.py</code> <pre><code>def parse_hierarchyLevel(subset_visit):\n    \"\"\"\n    Parse the hierarchy level from the subset_visit dictionary.\n\n    Args:\n        subset_visit (dict): The subset visit dictionary containing the hierarchy level.\n\n    Returns:\n        str: The hierarchy level of the visit.\n    \"\"\"\n    return subset_visit[\"hierarchyLevel\"]\n</code></pre>"},{"location":"gtl2geojson/#gtlparser.gtl2geojson.parse_point_latlong","title":"<code>parse_point_latlong(subset_visit)</code>","text":"<p>Parse the latitude and longitude from the subset_visit dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>subset_visit</code> <code>dict</code> <p>The subset visit dictionary containing the location information.</p> required <p>Returns:</p> Type Description <p>The latitude and longitude as floats.</p> Source code in <code>gtlparser/gtl2geojson.py</code> <pre><code>def parse_point_latlong(subset_visit):\n    \"\"\"\n    Parse the latitude and longitude from the subset_visit dictionary.\n\n    Args:\n        subset_visit (dict): The subset visit dictionary containing the location information.\n\n    Returns:\n        The latitude and longitude as floats.\n    \"\"\"\n\n    temp_subset = subset_visit.get(\"topCandidate\")\n    temp_lat, temp_long = (\n        temp_subset[\"placeLocation\"][\"latLng\"].replace(\"\u00b0\", \"\").split(\", \")\n    )\n    return float(temp_lat), float(temp_long)\n</code></pre>"},{"location":"gtl2geojson/#gtlparser.gtl2geojson.parse_probability","title":"<code>parse_probability(subset_visit)</code>","text":"<p>Parse the probability from the subset_visit dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>subset_visit</code> <code>dict</code> <p>The subset visit dictionary containing the probability.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The probability of the visit.</p> Source code in <code>gtlparser/gtl2geojson.py</code> <pre><code>def parse_probability(subset_visit):\n    \"\"\"\n    Parse the probability from the subset_visit dictionary.\n\n    Args:\n        subset_visit (dict): The subset visit dictionary containing the probability.\n\n    Returns:\n        float: The probability of the visit.\n    \"\"\"\n    return subset_visit[\"probability\"]\n</code></pre>"},{"location":"gtl2geojson/#gtlparser.gtl2geojson.parse_timelinePath","title":"<code>parse_timelinePath(in_json)</code>","text":"<p>Parse the timeline path from the json_data dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>json_data</code> <code>dict</code> <p>The JSON data containing the timeline path information.</p> required <p>Returns:</p> Type Description <code>FeatureCollection</code> <p>A collection of line features extracted from the JSON data.</p> Source code in <code>gtlparser/gtl2geojson.py</code> <pre><code>def parse_timelinePath(in_json):\n    \"\"\"\n    Parse the timeline path from the json_data dictionary.\n\n    Args:\n        json_data (dict): The JSON data containing the timeline path information.\n\n    Returns:\n        FeatureCollection: A collection of line features extracted from the JSON data.\n    \"\"\"\n    if in_json.startswith(\"http://\") or in_json.startswith(\"https://\"):\n        json_data = read_json_from_url(in_json)\n    elif os.path.exists(in_json):\n        json_data = json.loads(open(in_json, encoding=\"utf8\").read())\n\n    line_features = []\n    for item in json_data[\"semanticSegments\"]:\n        try:\n            item_keys = list(\n                item.keys()\n            )  # visit, timelinePath, timelineMemory, activity\n            if \"timelinePath\" in item_keys:\n                temp_startTime = item.get(\"startTime\")\n                temp_endTime = item.get(\"endTime\")\n                list_points = []\n                for timeline_path in item[\"timelinePath\"]:\n                    latitude, longitude = (\n                        timeline_path[\"point\"].replace(\"\u00b0\", \"\").split(\", \")\n                    )\n                    time = datetime.strptime(\n                        timeline_path[\"time\"], \"%Y-%m-%dT%H:%M:%S.%f%z\"\n                    )\n                    list_points.append((float(longitude), float(latitude)))\n                if len(list_points) &gt; 1:\n                    temp_line = LineString(list_points)\n                    line_features.append(\n                        Feature(\n                            geometry=temp_line,\n                            properties={\n                                \"startTime\": temp_startTime,\n                                \"endTime\": temp_endTime,\n                            },\n                        )\n                    )\n        except Exception as e:\n            raise Exception(e)\n    feature_collection_line = FeatureCollection(line_features)\n    return feature_collection_line\n</code></pre>"},{"location":"gtl2geojson/#gtlparser.gtl2geojson.parse_topCadidate_placeId","title":"<code>parse_topCadidate_placeId(subset_visit)</code>","text":"<p>Parse the place ID from the subset_visit dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>subset_visit</code> <code>dict</code> <p>The subset visit dictionary containing the place ID.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The place ID of the visit.</p> Source code in <code>gtlparser/gtl2geojson.py</code> <pre><code>def parse_topCadidate_placeId(subset_visit):\n    \"\"\"\n    Parse the place ID from the subset_visit dictionary.\n\n    Args:\n        subset_visit (dict): The subset visit dictionary containing the place ID.\n\n    Returns:\n        str: The place ID of the visit.\n    \"\"\"\n    return subset_visit[\"topCandidate\"][\"placeId\"]\n</code></pre>"},{"location":"gtl2geojson/#gtlparser.gtl2geojson.parse_topCadidate_probability","title":"<code>parse_topCadidate_probability(subset_visit)</code>","text":"<p>Parse the top candidate probability from the subset_visit dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>subset_visit</code> <code>dict</code> <p>The subset visit dictionary containing the top candidate probability.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The top candidate probability of the visit.</p> Source code in <code>gtlparser/gtl2geojson.py</code> <pre><code>def parse_topCadidate_probability(subset_visit):\n    \"\"\"\n    Parse the top candidate probability from the subset_visit dictionary.\n\n    Args:\n        subset_visit (dict): The subset visit dictionary containing the top candidate probability.\n\n    Returns:\n        float: The top candidate probability of the visit.\n    \"\"\"\n    return subset_visit[\"topCandidate\"][\"probability\"]\n</code></pre>"},{"location":"gtl2geojson/#gtlparser.gtl2geojson.parse_topCadidate_semanticType","title":"<code>parse_topCadidate_semanticType(subset_visit)</code>","text":"<p>Parse the semantic type from the subset_visit dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>subset_visit</code> <code>dict</code> <p>The subset visit dictionary containing the semantic type.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The semantic type of the visit.</p> Source code in <code>gtlparser/gtl2geojson.py</code> <pre><code>def parse_topCadidate_semanticType(subset_visit):\n    \"\"\"\n    Parse the semantic type from the subset_visit dictionary.\n\n    Args:\n        subset_visit (dict): The subset visit dictionary containing the semantic type.\n\n    Returns:\n        str: The semantic type of the visit.\n    \"\"\"\n    return subset_visit[\"topCandidate\"][\"semanticType\"]\n</code></pre>"},{"location":"gtl2geojson/#gtlparser.gtl2geojson.parse_visitPoint","title":"<code>parse_visitPoint(in_json, flag_allField=0)</code>","text":"<p>Parse the visit point from the json_data dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>json_data</code> <code>dict</code> <p>The JSON data containing the visit point information.</p> required <code>flag_allField</code> <code>int</code> <p>Flag to indicate whether to include all fields in the output.</p> <code>0</code> <p>Returns:</p> Type Description <code>FeatureCollection</code> <p>A collection of point features extracted from the JSON data.</p> Source code in <code>gtlparser/gtl2geojson.py</code> <pre><code>def parse_visitPoint(in_json, flag_allField=0):\n    \"\"\"\n    Parse the visit point from the json_data dictionary.\n\n    Args:\n        json_data (dict): The JSON data containing the visit point information.\n        flag_allField (int): Flag to indicate whether to include all fields in the output.\n\n    Returns:\n        FeatureCollection: A collection of point features extracted from the JSON data.\n    \"\"\"\n    if in_json.startswith(\"http://\") or in_json.startswith(\"https://\"):\n        json_data = read_json_from_url(in_json)\n    elif os.path.exists(in_json):\n        json_data = json.loads(open(in_json, encoding=\"utf8\").read())\n\n    point_features = []\n    for item in json_data[\"semanticSegments\"]:\n        try:\n            item_keys = list(\n                item.keys()\n            )  # visit, timelinePath, timelineMemory, activity\n            if \"visit\" in item_keys:\n                # print(\"processing point...\")\n                temp_startTime = item.get(\"startTime\")\n                temp_endTime = item.get(\"endTime\")\n                subset_visit = item.get(\"visit\")\n                temp_lat, temp_long = parse_point_latlong(subset_visit)\n                temp_point = Point((temp_long, temp_lat))\n                if flag_allField == 1:\n                    point_output = {\n                        \"startTime\": temp_startTime,\n                        \"endTime\": temp_endTime,\n                        \"hierarchyLevel\": parse_hierarchyLevel(subset_visit),\n                        \"probability\": parse_probability(subset_visit),\n                        \"placeId\": parse_topCadidate_placeId(subset_visit),\n                        \"semanticType\": parse_topCadidate_semanticType(subset_visit),\n                        \"topCadidate_probability\": parse_topCadidate_probability(\n                            subset_visit\n                        ),\n                    }\n                    point_features.append(\n                        Feature(geometry=temp_point, properties=point_output)\n                    )\n                else:\n                    point_output = {\n                        \"startTime\": temp_startTime,\n                        \"endTime\": temp_endTime,\n                    }\n                    point_features.append(\n                        Feature(geometry=temp_point, properties=point_output)\n                    )\n        except Exception as e:\n            raise Exception(e)\n    feature_collection_point = FeatureCollection(point_features)\n    return feature_collection_point\n</code></pre>"},{"location":"gtl2geojson/#gtlparser.gtl2geojson.read_json_from_url","title":"<code>read_json_from_url(url)</code>","text":"<p>Read JSON data from a URL.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL to read the JSON data from.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>The JSON data as a dictionary.</p> Source code in <code>gtlparser/gtl2geojson.py</code> <pre><code>def read_json_from_url(url):\n    \"\"\"\n    Read JSON data from a URL.\n\n    Args:\n        url (str): The URL to read the JSON data from.\n\n    Returns:\n        dict: The JSON data as a dictionary.\n    \"\"\"\n\n    import requests\n    import json\n\n    try:\n        response = requests.get(url)\n        response.raise_for_status()  # Raise HTTPError for bad responses (4xx or 5xx)\n        return response.json()\n    except requests.exceptions.RequestException as e:\n        print(f\"Request failed: {e}\")\n        return None\n    except json.decoder.JSONDecodeError as e:\n        print(f\"JSON Decode error: {e}\")\n        return None\n</code></pre>"},{"location":"gtlparser/","title":"gtlparser module","text":"<p>Main module.</p>"},{"location":"gtlparser/#gtlparser.gtlparser.Map","title":"<code> Map            (Map)         </code>","text":"<p>A custom Map class that inherits from ipyleaflet.Map and adds additional functionalities for basemap support, layer control, and vector data handling.</p> Source code in <code>gtlparser/gtlparser.py</code> <pre><code>class Map(ipyleaflet.Map):\n    \"\"\"\n    A custom Map class that inherits from ipyleaflet.Map and adds additional\n    functionalities for basemap support, layer control, and vector data handling.\n    \"\"\"\n\n    def __init__(self, center=[20, 0], zoom=2, height=\"600px\", **kwargs):\n        \"\"\"\n        Initializes the Map object, inherits from ipyleaflet.Map.\n\n        Args:\n            center (list): Initial center of the map [latitude, longitude].\n            zoom (int): Initial zoom level of the map.\n            height (str): Height of the map in CSS units (e.g., \"600px\").\n            **kwargs: Additional keyword arguments to pass to ipyleaflet.Map.\n        \"\"\"\n        super().__init__(center=center, zoom=zoom, **kwargs)\n        self.layout.height = height\n        self.scroll_wheel_zoom = True\n\n        self.output_widget = widgets.Output()\n\n        self.info_control = ipyleaflet.WidgetControl(\n            widget=self.output_widget, position=\"bottomright\"\n        )\n\n        self.add_control(self.info_control)\n\n        self._setup_hover_handler()\n\n    def _setup_hover_handler(self):\n        \"\"\"\n        Defines the internal hover handler method.\n        This method is called when a feature is hovered over on the map.\n        It displays the properties of the hovered feature in an output widget.\n        \"\"\"\n        from IPython.display import display\n\n        def hover_handler(event=None, feature=None, **kwargs):\n            \"\"\"\n            Handles the hover event on the map.\n            event: The event object containing information about the hover event.\n            feature: The feature being hovered over.\n            kwargs: Additional keyword arguments.\n            \"\"\"\n            self.output_widget.clear_output()\n\n            with self.output_widget:\n                if feature:\n                    properties = feature[\"properties\"]\n\n                    info_html = \"\"\"\n                    &lt;div style=\"padding: 5px; background-color: white; border: 1px solid grey;\"&gt;\n                    \"\"\"\n                    info_html += \"&lt;b&gt;Properties:&lt;/b&gt;&lt;br&gt;\"\n                    if properties:\n                        for key, value in properties.items():\n                            if key.lower() not in [\n                                \"geometry\",\n                                \"shape_length\",\n                                \"shape_area\",\n                            ]:\n                                info_html += f\"&lt;b&gt;{key}:&lt;/b&gt; {value}&lt;br&gt;\"\n                    else:\n                        info_html += \"No properties available.\"\n\n                    info_html += \"&lt;/div&gt;\"\n                    display(widgets.HTML(info_html))\n                else:\n                    display(widgets.HTML(\"Hover over a feature\"))\n\n        self.hover_handler_method = hover_handler\n\n    def add_basemap(self, basemap=\"OpenStreetMap\", **kwargs):\n        \"\"\"\n        Adds a basemap to the map.\n\n        Args:\n            basemap_name (str): The name of the basemap to be added.\n                Examples: 'OpenStreetMap', 'Esri.WorldImagery', 'OpenTopoMap'.\n            **kwargs: Additional keyword arguments to pass to ipyleaflet.TileLayer.\n\n        Raises:\n            ValueError: If the provided basemap_name is not found.\n\n        Returns:\n            None: Adds the basemap to the map.\n        \"\"\"\n        import xyzservices\n\n        try:\n            xyzservices_return = eval(f\"ipyleaflet.basemaps.{basemap}\")\n            if type(xyzservices_return) == xyzservices.lib.TileProvider:\n                url = xyzservices_return.build_url()\n            elif type(xyzservices_return) == xyzservices.lib.Bunch:\n                subset = kwargs.get(\"subset\")\n                if subset is None:\n                    subset = list(xyzservices_return.keys())[0]\n                url = eval(f\"ipyleaflet.basemaps.{basemap}.{subset}\").build_url()\n            layer = ipyleaflet.TileLayer(url=url, name=basemap + subset)\n            self.add(layer)\n        except:\n            raise ValueError(f\"Basemap '{basemap}' not found in ipyleaflet basemaps.\")\n\n    def add_basemap_gui(self, options=None, position=\"topright\"):\n        \"\"\"\n        Adds a GUI for selecting basemaps to the map.\n        Args:\n            options (list): List of available basemaps to choose from.\n                If None, defaults to a predefined list.\n            position (str): Position of the widget on the map.\n                Options: 'topleft', 'topright', 'bottomleft', 'bottomright'.\n\n        Behavior:\n            - A toggle button to show/hide the dropdown and close button.\n            - A dropdown menu to select the basemap.\n            - A close button to remove the widget from the map.\n\n        Events handlers:\n            - `on_toggle_change`: Toggles the visibility of the dropdown and close button.\n            - `on_button_click`: Closes the widget when the close button is clicked.\n            - `on_dropdown_change`: Changes the basemap when a new option is selected.\n        \"\"\"\n        if options is None:\n            options = [\n                \"OpenStreetMap.Mapnik\",\n                \"OpenTopoMap\",\n                \"Esri.WorldImagery\",\n                \"CartoDB.DarkMatter\",\n            ]\n\n        toggle = widgets.ToggleButton(\n            value=True,\n            button_style=\"\",\n            tooltip=\"Click me\",\n            icon=\"map\",\n        )\n        toggle.layout = widgets.Layout(width=\"38px\", height=\"38px\")\n\n        dropdown = widgets.Dropdown(\n            options=options,\n            value=options[0],\n            description=\"Basemap: \",\n            style={\"description_width\": \"initial\"},\n        )\n        dropdown.layout = widgets.Layout(width=\"250px\", height=\"38px\")\n\n        button = widgets.Button(\n            icon=\"times\",\n        )\n        button.layout = widgets.Layout(width=\"38px\", height=\"38px\")\n\n        hbox = widgets.HBox([toggle, dropdown, button])\n\n        def on_toggle_change(change):\n            if change[\"new\"]:\n                hbox.children = [toggle, dropdown, button]\n            else:\n                hbox.children = [toggle]\n\n        toggle.observe(on_toggle_change, names=\"value\")\n\n        def on_button_click(b):\n            hbox.close()\n            toggle.close()\n            dropdown.close()\n            button.close()\n\n        button.on_click(on_button_click)\n\n        def on_dropdown_change(change):\n            if change[\"new\"]:\n                self.layers = self.layers[:-2]\n                self.add_basemap(change[\"new\"])\n\n        dropdown.observe(on_dropdown_change, names=\"value\")\n\n        control = ipyleaflet.WidgetControl(widget=hbox, position=position)\n        self.add(control)\n\n    def add_search_control(self, position=\"topleft\", **kwargs):\n        \"\"\"\n        Adds a search control to the map.\n\n        Args:\n            position (str): Position of the search control on the map.\n                Options: 'topleft', 'topright', 'bottomleft', 'bottomright'.\n            **kwargs: Additional keyword arguments for ipyleaflet.SearchControl.\n\n        Returns:\n            None: Adds the search control to the map.\n        \"\"\"\n        url = \"https://nominatim.openstreetmap.org/search?format=json&amp;q={s}\"\n        search_control = ipyleaflet.SearchControl(\n            position=position, url=url, zoom=12, marker=None, **kwargs\n        )\n        self.add_control(search_control)\n\n    def add_widget(self, widget, position=\"topright\", **kwargs):\n        \"\"\"\n        Adds a widget to the map.\n\n        Args:\n            widget (ipywidgets.Widget): The widget to be added to the map.\n            position (str): Position of the widget on the map.\n                Options: 'topleft', 'topright', 'bottomleft', 'bottomright'.\n            **kwargs: Additional keyword arguments for ipyleaflet.WidgetControl.\n        \"\"\"\n        control = ipyleaflet.WidgetControl(widget=widget, position=position, **kwargs)\n        self.add(control)\n\n    def add_layer_control(self):\n        \"\"\"\n        Adds a layer control widget to the map to manage different layers.\n\n        Args:\n            None\n\n        Returns:\n            None: Adds a layer control widget to the map.\n        \"\"\"\n        layer_control = ipyleaflet.LayersControl(position=\"topright\")\n        self.add_control(layer_control)\n\n    def add_vector(self, data, **kwargs):\n        \"\"\"\n        Adds vector data (GeoJSON/Shapefile) to the map.\n\n        Args:\n            data (str or GeoDataFrame): The vector data to be added to the map.\n                Can be a file path (str) or a GeoDataFrame.\n            **kwargs: Additional keyword arguments for the GeoJSON layer.\n\n        Raises:\n            ValueError: If the data type is invalid.\n        \"\"\"\n        import geopandas as gpd\n\n        if isinstance(data, str):\n            gdf = gpd.read_file(data)\n            self.add_gdf(gdf, **kwargs)\n        elif isinstance(data, gpd.GeoDataFrame):\n            self.add_gdf(data, **kwargs)\n        elif isinstance(data, dict):\n            self.add_geojson(data, **kwargs)\n        else:\n            raise ValueError(\"Invalid data type.\")\n\n    def add_google_maps(self, map_type=\"ROADMAP\"):\n        \"\"\"\n        Adds Google Maps basemap to the map.\n\n        Args:\n            map_type (str): The type of Google Maps to be added.\n                Options: 'ROADMAP', 'SATELLITE', 'HYBRID', 'TERRAIN'.\n\n        Returns:\n            None: Adds the Google Maps basemap to the map.\n        \"\"\"\n        map_types = {\n            \"ROADMAP\": \"m\",\n            \"SATELLITE\": \"s\",\n            \"HYBRID\": \"y\",\n            \"TERRAIN\": \"p\",\n        }\n        map_type = map_types[map_type.upper()]\n\n        url = (\n            f\"https://mt1.google.com/vt/lyrs={map_type.lower()}&amp;x={{x}}&amp;y={{y}}&amp;z={{z}}\"\n        )\n        layer = ipyleaflet.TileLayer(url=url, name=\"Google Maps\")\n        self.add(layer)\n\n    def add_geojson(self, data, layer_style=None, hover_style=None, **kwargs):\n        \"\"\"Adds a GeoJSON layer to the map with automatic hover inspection.\n\n        Args:\n            data (str or dict): The GeoJson data. Can be a file path (str) or a dictionary.\n            layer_style (dict, optional): Style to apply to the layer.\n                                         Defaults to {\"color\": \"blue\", \"fillOpacity\": 0.5} for polygons,\n                                        {\"color\": \"blue\", \"weight\": 3, \"opacity\": 0.8} for lines,\n                                        {\"radius\": 5, \"color\": \"blue\", 'fillColor': '#3388ff', 'fillOpacity': 0.8, 'weight': 1} for points.\n            hover_style (dict, optional): Style to apply when hovering over features.\n                                         Defaults to {\"color\": \"yellow\", \"fillOpacity\": 0.2} for polygons,\n                                         {\"color\": \"yellow\", \"weight\": 4} for lines,\n                                         {\"radius\": 7, \"color\": \"yellow\", \"fillColor\": \"yellow\", \"fillOpacity\": 0.8} for points.\n            **kwargs: Additional keyword arguments for the ipyleaflet.GeoJSON layer.\n        \"\"\"\n        import geopandas as gpd\n\n        if isinstance(data, str):\n            try:\n                gdf = gpd.read_file(data)\n                geojson_data = gdf.__geo_interface__\n                geometry_type = (\n                    gdf.geometry.iloc[0].geom_type if not gdf.empty else None\n                )\n            except Exception as e:\n                print(f\"Error reading GeoJSON file: {e}\")\n                return\n        elif isinstance(data, dict):\n            geojson_data = data\n            geometry_type = (\n                geojson_data[\"features\"][0][\"geometry\"][\"type\"]\n                if geojson_data.get(\"features\")\n                else None\n            )\n        else:\n            raise ValueError(\"Data must be a file path (str) or a dictionary.\")\n        print(geometry_type)\n\n        if layer_style is None:\n            if geometry_type == \"Polygon\":\n                layer_style = {\"color\": \"blue\", \"fillOpacity\": 0.5}\n            elif geometry_type == \"LineString\":\n                layer_style = {\"color\": \"blue\", \"weight\": 3, \"opacity\": 0.8}\n            elif geometry_type == \"Point\":\n                layer_style = {\n                    \"radius\": 5,\n                    \"color\": \"blue\",\n                    \"fillColor\": \"#3388ff\",\n                    \"fillOpacity\": 0.8,\n                    \"weight\": 1,\n                }\n            else:\n                layer_style = {}\n\n        if hover_style is None:\n            if geometry_type == \"Polygon\":\n                hover_style = {\"color\": \"yellow\", \"fillOpacity\": 0.2}\n            elif geometry_type == \"LineString\":\n                hover_style = {\"color\": \"yellow\", \"weight\": 4, \"opacity\": 1}\n            elif geometry_type == \"Point\":\n                hover_style = {\"fillColor\": \"red\", \"fillOpacity\": 1}\n            else:\n                hover_style = {}\n\n        print(layer_style, hover_style)\n\n        if geometry_type == \"Point\":\n            layer = ipyleaflet.GeoJSON(\n                data=geojson_data,\n                point_style=layer_style,\n                hover_style=hover_style,\n                **kwargs,\n            )\n        elif geometry_type == \"LineString\":\n            layer = ipyleaflet.GeoJSON(\n                data=geojson_data, style=layer_style, hover_style=hover_style, **kwargs\n            )\n        elif geometry_type == \"Polygon\":\n            layer = ipyleaflet.GeoJSON(\n                data=geojson_data, style=layer_style, hover_style=hover_style, **kwargs\n            )\n        layer.on_hover(self.hover_handler_method)\n        self.add_layer(layer)\n\n    def add_shp(self, data, **kwargs):\n        \"\"\"Adds a shapefile layer to the map.\n\n        Args:\n            data (str): Path to the shapefile.\n            **kwargs: Additional keyword arguments for the ipyleaflet.GeoJSON layer.\n        \"\"\"\n        import geopandas as gpd\n\n        gdf = gpd.read_file(data)\n        gdf = gdf.to_crs(epsg=4326)\n        geojson = gdf.__geo_interface__\n        self.add_geojson(geojson, **kwargs)\n\n    def add_gdf(self, gdf, **kwargs):\n        \"\"\"Adds a GeoDataFrame layer to the map.\n\n        Args:\n            gdf (GeoDataFrame): The GeoDataFrame to be added to the map.\n            **kwargs: Additional keyword arguments for the ipyleaflet.GeoJSON layer.\n        \"\"\"\n        gdf = gdf.to_crs(epsg=4326)\n        geojson = gdf.__geo_interface__\n        self.add_geojson(geojson, **kwargs)\n\n    def add_raster(self, filepath, colormap=\"viridis\", opacity=1.0, **kwargs):\n        \"\"\"Adds a raster layer to the map.\n\n        Args:\n            filepath (str): Path to the raster file.\n            colormap (str): Colormap to be applied to the raster data.\n            opacity (float): Opacity of the raster layer (0.0 to 1.0).\n            **kwargs: Additional keyword arguments for the ipyleaflet.ImageOverlay layer.\n        \"\"\"\n        from localtileserver import TileClient, get_leaflet_tile_layer\n\n        client = TileClient(filepath)\n        tile_layer = get_leaflet_tile_layer(\n            client, colormap=colormap, opacity=opacity, **kwargs\n        )\n\n        self.add(tile_layer)\n        self.center = client.center()\n        self.zoom = client.default_zoom\n\n    def add_image(self, image, bounds=None, opacity=1.0, **kwargs):\n        \"\"\"Adds an image overlay to the map.\n\n        Args:\n            image (str): Path to the image file.\n            bounds (list): Bounds of the image in the format [[lat1, lon1], [lat2, lon2]].\n            opacity (float): Opacity of the image overlay (0.0 to 1.0).\n            **kwargs: Additional keyword arguments for the ipyleaflet.ImageOverlay layer.\n\n        Raises:\n            ValueError: If the bounds are not provided.\n        \"\"\"\n        from ipyleaflet import ImageOverlay\n\n        if bounds is None:\n            bounds = [[-90, -180], [90, 180]]\n        layer = ImageOverlay(url=image, bounds=bounds, opacity=opacity, **kwargs)\n        self.add(layer)\n\n    def add_video(self, video, bounds=None, opacity=1.0, **kwargs):\n        \"\"\"Adds a video overlay to the map.\n\n        Args:\n            video (str): Path to the video file.\n            bounds (list): Bounds of the video in the format [[lat1, lon1], [lat2, lon2]].\n            opacity (float): Opacity of the video overlay (0.0 to 1.0).\n            **kwargs: Additional keyword arguments for the ipyleaflet.VideoOverlay layer.\n\n        Raises:\n            ValueError: If the bounds are not provided.\n        \"\"\"\n        from ipyleaflet import VideoOverlay\n\n        if bounds is None:\n            bounds = [[-90, -180], [90, 180]]\n        layer = VideoOverlay(url=video, bounds=bounds, opacity=opacity, **kwargs)\n        self.add(layer)\n\n    def add_WMS_layer(\n        self, url, layers, name, format=\"image/png\", transparent=True, **kwargs\n    ):\n        \"\"\"Adds a WMS layer to the map.\n\n        Args:\n            url (str): URL of the WMS layer.\n            layers (str): Comma-separated list of layer names.\n            name (str): Name of the layer.\n            format (str): Format of the layer (default: \"image/png\").\n            transparent (bool): Whether the layer is transparent (default: True).\n            **kwargs: Additional keyword arguments for the ipyleaflet.WMSLayer layer.\n\n        Raises:\n            ValueError: If the WMSLayer is not found.\n        \"\"\"\n        from ipyleaflet import WMSLayer\n\n        try:\n            layer = WMSLayer(\n                url=url,\n                layers=layers,\n                name=name,\n                format=format,\n                transparent=transparent,\n                **kwargs,\n            )\n            self.add(layer)\n        except:\n            raise ValueError(f\"WMS Layer '{layer}' not found.\")\n</code></pre>"},{"location":"gtlparser/#gtlparser.gtlparser.Map.__init__","title":"<code>__init__(self, center=[20, 0], zoom=2, height='600px', **kwargs)</code>  <code>special</code>","text":"<p>Initializes the Map object, inherits from ipyleaflet.Map.</p> <p>Parameters:</p> Name Type Description Default <code>center</code> <code>list</code> <p>Initial center of the map [latitude, longitude].</p> <code>[20, 0]</code> <code>zoom</code> <code>int</code> <p>Initial zoom level of the map.</p> <code>2</code> <code>height</code> <code>str</code> <p>Height of the map in CSS units (e.g., \"600px\").</p> <code>'600px'</code> <code>**kwargs</code> <p>Additional keyword arguments to pass to ipyleaflet.Map.</p> <code>{}</code> Source code in <code>gtlparser/gtlparser.py</code> <pre><code>def __init__(self, center=[20, 0], zoom=2, height=\"600px\", **kwargs):\n    \"\"\"\n    Initializes the Map object, inherits from ipyleaflet.Map.\n\n    Args:\n        center (list): Initial center of the map [latitude, longitude].\n        zoom (int): Initial zoom level of the map.\n        height (str): Height of the map in CSS units (e.g., \"600px\").\n        **kwargs: Additional keyword arguments to pass to ipyleaflet.Map.\n    \"\"\"\n    super().__init__(center=center, zoom=zoom, **kwargs)\n    self.layout.height = height\n    self.scroll_wheel_zoom = True\n\n    self.output_widget = widgets.Output()\n\n    self.info_control = ipyleaflet.WidgetControl(\n        widget=self.output_widget, position=\"bottomright\"\n    )\n\n    self.add_control(self.info_control)\n\n    self._setup_hover_handler()\n</code></pre>"},{"location":"gtlparser/#gtlparser.gtlparser.Map.add_WMS_layer","title":"<code>add_WMS_layer(self, url, layers, name, format='image/png', transparent=True, **kwargs)</code>","text":"<p>Adds a WMS layer to the map.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>URL of the WMS layer.</p> required <code>layers</code> <code>str</code> <p>Comma-separated list of layer names.</p> required <code>name</code> <code>str</code> <p>Name of the layer.</p> required <code>format</code> <code>str</code> <p>Format of the layer (default: \"image/png\").</p> <code>'image/png'</code> <code>transparent</code> <code>bool</code> <p>Whether the layer is transparent (default: True).</p> <code>True</code> <code>**kwargs</code> <p>Additional keyword arguments for the ipyleaflet.WMSLayer layer.</p> <code>{}</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the WMSLayer is not found.</p> Source code in <code>gtlparser/gtlparser.py</code> <pre><code>def add_WMS_layer(\n    self, url, layers, name, format=\"image/png\", transparent=True, **kwargs\n):\n    \"\"\"Adds a WMS layer to the map.\n\n    Args:\n        url (str): URL of the WMS layer.\n        layers (str): Comma-separated list of layer names.\n        name (str): Name of the layer.\n        format (str): Format of the layer (default: \"image/png\").\n        transparent (bool): Whether the layer is transparent (default: True).\n        **kwargs: Additional keyword arguments for the ipyleaflet.WMSLayer layer.\n\n    Raises:\n        ValueError: If the WMSLayer is not found.\n    \"\"\"\n    from ipyleaflet import WMSLayer\n\n    try:\n        layer = WMSLayer(\n            url=url,\n            layers=layers,\n            name=name,\n            format=format,\n            transparent=transparent,\n            **kwargs,\n        )\n        self.add(layer)\n    except:\n        raise ValueError(f\"WMS Layer '{layer}' not found.\")\n</code></pre>"},{"location":"gtlparser/#gtlparser.gtlparser.Map.add_basemap","title":"<code>add_basemap(self, basemap='OpenStreetMap', **kwargs)</code>","text":"<p>Adds a basemap to the map.</p> <p>Parameters:</p> Name Type Description Default <code>basemap_name</code> <code>str</code> <p>The name of the basemap to be added. Examples: 'OpenStreetMap', 'Esri.WorldImagery', 'OpenTopoMap'.</p> required <code>**kwargs</code> <p>Additional keyword arguments to pass to ipyleaflet.TileLayer.</p> <code>{}</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the provided basemap_name is not found.</p> <p>Returns:</p> Type Description <code>None</code> <p>Adds the basemap to the map.</p> Source code in <code>gtlparser/gtlparser.py</code> <pre><code>def add_basemap(self, basemap=\"OpenStreetMap\", **kwargs):\n    \"\"\"\n    Adds a basemap to the map.\n\n    Args:\n        basemap_name (str): The name of the basemap to be added.\n            Examples: 'OpenStreetMap', 'Esri.WorldImagery', 'OpenTopoMap'.\n        **kwargs: Additional keyword arguments to pass to ipyleaflet.TileLayer.\n\n    Raises:\n        ValueError: If the provided basemap_name is not found.\n\n    Returns:\n        None: Adds the basemap to the map.\n    \"\"\"\n    import xyzservices\n\n    try:\n        xyzservices_return = eval(f\"ipyleaflet.basemaps.{basemap}\")\n        if type(xyzservices_return) == xyzservices.lib.TileProvider:\n            url = xyzservices_return.build_url()\n        elif type(xyzservices_return) == xyzservices.lib.Bunch:\n            subset = kwargs.get(\"subset\")\n            if subset is None:\n                subset = list(xyzservices_return.keys())[0]\n            url = eval(f\"ipyleaflet.basemaps.{basemap}.{subset}\").build_url()\n        layer = ipyleaflet.TileLayer(url=url, name=basemap + subset)\n        self.add(layer)\n    except:\n        raise ValueError(f\"Basemap '{basemap}' not found in ipyleaflet basemaps.\")\n</code></pre>"},{"location":"gtlparser/#gtlparser.gtlparser.Map.add_basemap_gui","title":"<code>add_basemap_gui(self, options=None, position='topright')</code>","text":"<p>Adds a GUI for selecting basemaps to the map.</p> <p>Parameters:</p> Name Type Description Default <code>options</code> <code>list</code> <p>List of available basemaps to choose from. If None, defaults to a predefined list.</p> <code>None</code> <code>position</code> <code>str</code> <p>Position of the widget on the map. Options: 'topleft', 'topright', 'bottomleft', 'bottomright'.</p> <code>'topright'</code> <p>Behavior</p> <ul> <li>A toggle button to show/hide the dropdown and close button.</li> <li>A dropdown menu to select the basemap.</li> <li>A close button to remove the widget from the map.</li> </ul> <p>Events handlers:     - <code>on_toggle_change</code>: Toggles the visibility of the dropdown and close button.     - <code>on_button_click</code>: Closes the widget when the close button is clicked.     - <code>on_dropdown_change</code>: Changes the basemap when a new option is selected.</p> Source code in <code>gtlparser/gtlparser.py</code> <pre><code>def add_basemap_gui(self, options=None, position=\"topright\"):\n    \"\"\"\n    Adds a GUI for selecting basemaps to the map.\n    Args:\n        options (list): List of available basemaps to choose from.\n            If None, defaults to a predefined list.\n        position (str): Position of the widget on the map.\n            Options: 'topleft', 'topright', 'bottomleft', 'bottomright'.\n\n    Behavior:\n        - A toggle button to show/hide the dropdown and close button.\n        - A dropdown menu to select the basemap.\n        - A close button to remove the widget from the map.\n\n    Events handlers:\n        - `on_toggle_change`: Toggles the visibility of the dropdown and close button.\n        - `on_button_click`: Closes the widget when the close button is clicked.\n        - `on_dropdown_change`: Changes the basemap when a new option is selected.\n    \"\"\"\n    if options is None:\n        options = [\n            \"OpenStreetMap.Mapnik\",\n            \"OpenTopoMap\",\n            \"Esri.WorldImagery\",\n            \"CartoDB.DarkMatter\",\n        ]\n\n    toggle = widgets.ToggleButton(\n        value=True,\n        button_style=\"\",\n        tooltip=\"Click me\",\n        icon=\"map\",\n    )\n    toggle.layout = widgets.Layout(width=\"38px\", height=\"38px\")\n\n    dropdown = widgets.Dropdown(\n        options=options,\n        value=options[0],\n        description=\"Basemap: \",\n        style={\"description_width\": \"initial\"},\n    )\n    dropdown.layout = widgets.Layout(width=\"250px\", height=\"38px\")\n\n    button = widgets.Button(\n        icon=\"times\",\n    )\n    button.layout = widgets.Layout(width=\"38px\", height=\"38px\")\n\n    hbox = widgets.HBox([toggle, dropdown, button])\n\n    def on_toggle_change(change):\n        if change[\"new\"]:\n            hbox.children = [toggle, dropdown, button]\n        else:\n            hbox.children = [toggle]\n\n    toggle.observe(on_toggle_change, names=\"value\")\n\n    def on_button_click(b):\n        hbox.close()\n        toggle.close()\n        dropdown.close()\n        button.close()\n\n    button.on_click(on_button_click)\n\n    def on_dropdown_change(change):\n        if change[\"new\"]:\n            self.layers = self.layers[:-2]\n            self.add_basemap(change[\"new\"])\n\n    dropdown.observe(on_dropdown_change, names=\"value\")\n\n    control = ipyleaflet.WidgetControl(widget=hbox, position=position)\n    self.add(control)\n</code></pre>"},{"location":"gtlparser/#gtlparser.gtlparser.Map.add_gdf","title":"<code>add_gdf(self, gdf, **kwargs)</code>","text":"<p>Adds a GeoDataFrame layer to the map.</p> <p>Parameters:</p> Name Type Description Default <code>gdf</code> <code>GeoDataFrame</code> <p>The GeoDataFrame to be added to the map.</p> required <code>**kwargs</code> <p>Additional keyword arguments for the ipyleaflet.GeoJSON layer.</p> <code>{}</code> Source code in <code>gtlparser/gtlparser.py</code> <pre><code>def add_gdf(self, gdf, **kwargs):\n    \"\"\"Adds a GeoDataFrame layer to the map.\n\n    Args:\n        gdf (GeoDataFrame): The GeoDataFrame to be added to the map.\n        **kwargs: Additional keyword arguments for the ipyleaflet.GeoJSON layer.\n    \"\"\"\n    gdf = gdf.to_crs(epsg=4326)\n    geojson = gdf.__geo_interface__\n    self.add_geojson(geojson, **kwargs)\n</code></pre>"},{"location":"gtlparser/#gtlparser.gtlparser.Map.add_geojson","title":"<code>add_geojson(self, data, layer_style=None, hover_style=None, **kwargs)</code>","text":"<p>Adds a GeoJSON layer to the map with automatic hover inspection.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str or dict</code> <p>The GeoJson data. Can be a file path (str) or a dictionary.</p> required <code>layer_style</code> <code>dict</code> <p>Style to apply to the layer.                          Defaults to {\"color\": \"blue\", \"fillOpacity\": 0.5} for polygons,                         {\"color\": \"blue\", \"weight\": 3, \"opacity\": 0.8} for lines,                         {\"radius\": 5, \"color\": \"blue\", 'fillColor': '#3388ff', 'fillOpacity': 0.8, 'weight': 1} for points.</p> <code>None</code> <code>hover_style</code> <code>dict</code> <p>Style to apply when hovering over features.                          Defaults to {\"color\": \"yellow\", \"fillOpacity\": 0.2} for polygons,                          {\"color\": \"yellow\", \"weight\": 4} for lines,                          {\"radius\": 7, \"color\": \"yellow\", \"fillColor\": \"yellow\", \"fillOpacity\": 0.8} for points.</p> <code>None</code> <code>**kwargs</code> <p>Additional keyword arguments for the ipyleaflet.GeoJSON layer.</p> <code>{}</code> Source code in <code>gtlparser/gtlparser.py</code> <pre><code>def add_geojson(self, data, layer_style=None, hover_style=None, **kwargs):\n    \"\"\"Adds a GeoJSON layer to the map with automatic hover inspection.\n\n    Args:\n        data (str or dict): The GeoJson data. Can be a file path (str) or a dictionary.\n        layer_style (dict, optional): Style to apply to the layer.\n                                     Defaults to {\"color\": \"blue\", \"fillOpacity\": 0.5} for polygons,\n                                    {\"color\": \"blue\", \"weight\": 3, \"opacity\": 0.8} for lines,\n                                    {\"radius\": 5, \"color\": \"blue\", 'fillColor': '#3388ff', 'fillOpacity': 0.8, 'weight': 1} for points.\n        hover_style (dict, optional): Style to apply when hovering over features.\n                                     Defaults to {\"color\": \"yellow\", \"fillOpacity\": 0.2} for polygons,\n                                     {\"color\": \"yellow\", \"weight\": 4} for lines,\n                                     {\"radius\": 7, \"color\": \"yellow\", \"fillColor\": \"yellow\", \"fillOpacity\": 0.8} for points.\n        **kwargs: Additional keyword arguments for the ipyleaflet.GeoJSON layer.\n    \"\"\"\n    import geopandas as gpd\n\n    if isinstance(data, str):\n        try:\n            gdf = gpd.read_file(data)\n            geojson_data = gdf.__geo_interface__\n            geometry_type = (\n                gdf.geometry.iloc[0].geom_type if not gdf.empty else None\n            )\n        except Exception as e:\n            print(f\"Error reading GeoJSON file: {e}\")\n            return\n    elif isinstance(data, dict):\n        geojson_data = data\n        geometry_type = (\n            geojson_data[\"features\"][0][\"geometry\"][\"type\"]\n            if geojson_data.get(\"features\")\n            else None\n        )\n    else:\n        raise ValueError(\"Data must be a file path (str) or a dictionary.\")\n    print(geometry_type)\n\n    if layer_style is None:\n        if geometry_type == \"Polygon\":\n            layer_style = {\"color\": \"blue\", \"fillOpacity\": 0.5}\n        elif geometry_type == \"LineString\":\n            layer_style = {\"color\": \"blue\", \"weight\": 3, \"opacity\": 0.8}\n        elif geometry_type == \"Point\":\n            layer_style = {\n                \"radius\": 5,\n                \"color\": \"blue\",\n                \"fillColor\": \"#3388ff\",\n                \"fillOpacity\": 0.8,\n                \"weight\": 1,\n            }\n        else:\n            layer_style = {}\n\n    if hover_style is None:\n        if geometry_type == \"Polygon\":\n            hover_style = {\"color\": \"yellow\", \"fillOpacity\": 0.2}\n        elif geometry_type == \"LineString\":\n            hover_style = {\"color\": \"yellow\", \"weight\": 4, \"opacity\": 1}\n        elif geometry_type == \"Point\":\n            hover_style = {\"fillColor\": \"red\", \"fillOpacity\": 1}\n        else:\n            hover_style = {}\n\n    print(layer_style, hover_style)\n\n    if geometry_type == \"Point\":\n        layer = ipyleaflet.GeoJSON(\n            data=geojson_data,\n            point_style=layer_style,\n            hover_style=hover_style,\n            **kwargs,\n        )\n    elif geometry_type == \"LineString\":\n        layer = ipyleaflet.GeoJSON(\n            data=geojson_data, style=layer_style, hover_style=hover_style, **kwargs\n        )\n    elif geometry_type == \"Polygon\":\n        layer = ipyleaflet.GeoJSON(\n            data=geojson_data, style=layer_style, hover_style=hover_style, **kwargs\n        )\n    layer.on_hover(self.hover_handler_method)\n    self.add_layer(layer)\n</code></pre>"},{"location":"gtlparser/#gtlparser.gtlparser.Map.add_google_maps","title":"<code>add_google_maps(self, map_type='ROADMAP')</code>","text":"<p>Adds Google Maps basemap to the map.</p> <p>Parameters:</p> Name Type Description Default <code>map_type</code> <code>str</code> <p>The type of Google Maps to be added. Options: 'ROADMAP', 'SATELLITE', 'HYBRID', 'TERRAIN'.</p> <code>'ROADMAP'</code> <p>Returns:</p> Type Description <code>None</code> <p>Adds the Google Maps basemap to the map.</p> Source code in <code>gtlparser/gtlparser.py</code> <pre><code>def add_google_maps(self, map_type=\"ROADMAP\"):\n    \"\"\"\n    Adds Google Maps basemap to the map.\n\n    Args:\n        map_type (str): The type of Google Maps to be added.\n            Options: 'ROADMAP', 'SATELLITE', 'HYBRID', 'TERRAIN'.\n\n    Returns:\n        None: Adds the Google Maps basemap to the map.\n    \"\"\"\n    map_types = {\n        \"ROADMAP\": \"m\",\n        \"SATELLITE\": \"s\",\n        \"HYBRID\": \"y\",\n        \"TERRAIN\": \"p\",\n    }\n    map_type = map_types[map_type.upper()]\n\n    url = (\n        f\"https://mt1.google.com/vt/lyrs={map_type.lower()}&amp;x={{x}}&amp;y={{y}}&amp;z={{z}}\"\n    )\n    layer = ipyleaflet.TileLayer(url=url, name=\"Google Maps\")\n    self.add(layer)\n</code></pre>"},{"location":"gtlparser/#gtlparser.gtlparser.Map.add_image","title":"<code>add_image(self, image, bounds=None, opacity=1.0, **kwargs)</code>","text":"<p>Adds an image overlay to the map.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>str</code> <p>Path to the image file.</p> required <code>bounds</code> <code>list</code> <p>Bounds of the image in the format [[lat1, lon1], [lat2, lon2]].</p> <code>None</code> <code>opacity</code> <code>float</code> <p>Opacity of the image overlay (0.0 to 1.0).</p> <code>1.0</code> <code>**kwargs</code> <p>Additional keyword arguments for the ipyleaflet.ImageOverlay layer.</p> <code>{}</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the bounds are not provided.</p> Source code in <code>gtlparser/gtlparser.py</code> <pre><code>def add_image(self, image, bounds=None, opacity=1.0, **kwargs):\n    \"\"\"Adds an image overlay to the map.\n\n    Args:\n        image (str): Path to the image file.\n        bounds (list): Bounds of the image in the format [[lat1, lon1], [lat2, lon2]].\n        opacity (float): Opacity of the image overlay (0.0 to 1.0).\n        **kwargs: Additional keyword arguments for the ipyleaflet.ImageOverlay layer.\n\n    Raises:\n        ValueError: If the bounds are not provided.\n    \"\"\"\n    from ipyleaflet import ImageOverlay\n\n    if bounds is None:\n        bounds = [[-90, -180], [90, 180]]\n    layer = ImageOverlay(url=image, bounds=bounds, opacity=opacity, **kwargs)\n    self.add(layer)\n</code></pre>"},{"location":"gtlparser/#gtlparser.gtlparser.Map.add_layer_control","title":"<code>add_layer_control(self)</code>","text":"<p>Adds a layer control widget to the map to manage different layers.</p> <p>Returns:</p> Type Description <code>None</code> <p>Adds a layer control widget to the map.</p> Source code in <code>gtlparser/gtlparser.py</code> <pre><code>def add_layer_control(self):\n    \"\"\"\n    Adds a layer control widget to the map to manage different layers.\n\n    Args:\n        None\n\n    Returns:\n        None: Adds a layer control widget to the map.\n    \"\"\"\n    layer_control = ipyleaflet.LayersControl(position=\"topright\")\n    self.add_control(layer_control)\n</code></pre>"},{"location":"gtlparser/#gtlparser.gtlparser.Map.add_raster","title":"<code>add_raster(self, filepath, colormap='viridis', opacity=1.0, **kwargs)</code>","text":"<p>Adds a raster layer to the map.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>Path to the raster file.</p> required <code>colormap</code> <code>str</code> <p>Colormap to be applied to the raster data.</p> <code>'viridis'</code> <code>opacity</code> <code>float</code> <p>Opacity of the raster layer (0.0 to 1.0).</p> <code>1.0</code> <code>**kwargs</code> <p>Additional keyword arguments for the ipyleaflet.ImageOverlay layer.</p> <code>{}</code> Source code in <code>gtlparser/gtlparser.py</code> <pre><code>def add_raster(self, filepath, colormap=\"viridis\", opacity=1.0, **kwargs):\n    \"\"\"Adds a raster layer to the map.\n\n    Args:\n        filepath (str): Path to the raster file.\n        colormap (str): Colormap to be applied to the raster data.\n        opacity (float): Opacity of the raster layer (0.0 to 1.0).\n        **kwargs: Additional keyword arguments for the ipyleaflet.ImageOverlay layer.\n    \"\"\"\n    from localtileserver import TileClient, get_leaflet_tile_layer\n\n    client = TileClient(filepath)\n    tile_layer = get_leaflet_tile_layer(\n        client, colormap=colormap, opacity=opacity, **kwargs\n    )\n\n    self.add(tile_layer)\n    self.center = client.center()\n    self.zoom = client.default_zoom\n</code></pre>"},{"location":"gtlparser/#gtlparser.gtlparser.Map.add_search_control","title":"<code>add_search_control(self, position='topleft', **kwargs)</code>","text":"<p>Adds a search control to the map.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>str</code> <p>Position of the search control on the map. Options: 'topleft', 'topright', 'bottomleft', 'bottomright'.</p> <code>'topleft'</code> <code>**kwargs</code> <p>Additional keyword arguments for ipyleaflet.SearchControl.</p> <code>{}</code> <p>Returns:</p> Type Description <code>None</code> <p>Adds the search control to the map.</p> Source code in <code>gtlparser/gtlparser.py</code> <pre><code>def add_search_control(self, position=\"topleft\", **kwargs):\n    \"\"\"\n    Adds a search control to the map.\n\n    Args:\n        position (str): Position of the search control on the map.\n            Options: 'topleft', 'topright', 'bottomleft', 'bottomright'.\n        **kwargs: Additional keyword arguments for ipyleaflet.SearchControl.\n\n    Returns:\n        None: Adds the search control to the map.\n    \"\"\"\n    url = \"https://nominatim.openstreetmap.org/search?format=json&amp;q={s}\"\n    search_control = ipyleaflet.SearchControl(\n        position=position, url=url, zoom=12, marker=None, **kwargs\n    )\n    self.add_control(search_control)\n</code></pre>"},{"location":"gtlparser/#gtlparser.gtlparser.Map.add_shp","title":"<code>add_shp(self, data, **kwargs)</code>","text":"<p>Adds a shapefile layer to the map.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str</code> <p>Path to the shapefile.</p> required <code>**kwargs</code> <p>Additional keyword arguments for the ipyleaflet.GeoJSON layer.</p> <code>{}</code> Source code in <code>gtlparser/gtlparser.py</code> <pre><code>def add_shp(self, data, **kwargs):\n    \"\"\"Adds a shapefile layer to the map.\n\n    Args:\n        data (str): Path to the shapefile.\n        **kwargs: Additional keyword arguments for the ipyleaflet.GeoJSON layer.\n    \"\"\"\n    import geopandas as gpd\n\n    gdf = gpd.read_file(data)\n    gdf = gdf.to_crs(epsg=4326)\n    geojson = gdf.__geo_interface__\n    self.add_geojson(geojson, **kwargs)\n</code></pre>"},{"location":"gtlparser/#gtlparser.gtlparser.Map.add_vector","title":"<code>add_vector(self, data, **kwargs)</code>","text":"<p>Adds vector data (GeoJSON/Shapefile) to the map.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str or GeoDataFrame</code> <p>The vector data to be added to the map. Can be a file path (str) or a GeoDataFrame.</p> required <code>**kwargs</code> <p>Additional keyword arguments for the GeoJSON layer.</p> <code>{}</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the data type is invalid.</p> Source code in <code>gtlparser/gtlparser.py</code> <pre><code>def add_vector(self, data, **kwargs):\n    \"\"\"\n    Adds vector data (GeoJSON/Shapefile) to the map.\n\n    Args:\n        data (str or GeoDataFrame): The vector data to be added to the map.\n            Can be a file path (str) or a GeoDataFrame.\n        **kwargs: Additional keyword arguments for the GeoJSON layer.\n\n    Raises:\n        ValueError: If the data type is invalid.\n    \"\"\"\n    import geopandas as gpd\n\n    if isinstance(data, str):\n        gdf = gpd.read_file(data)\n        self.add_gdf(gdf, **kwargs)\n    elif isinstance(data, gpd.GeoDataFrame):\n        self.add_gdf(data, **kwargs)\n    elif isinstance(data, dict):\n        self.add_geojson(data, **kwargs)\n    else:\n        raise ValueError(\"Invalid data type.\")\n</code></pre>"},{"location":"gtlparser/#gtlparser.gtlparser.Map.add_video","title":"<code>add_video(self, video, bounds=None, opacity=1.0, **kwargs)</code>","text":"<p>Adds a video overlay to the map.</p> <p>Parameters:</p> Name Type Description Default <code>video</code> <code>str</code> <p>Path to the video file.</p> required <code>bounds</code> <code>list</code> <p>Bounds of the video in the format [[lat1, lon1], [lat2, lon2]].</p> <code>None</code> <code>opacity</code> <code>float</code> <p>Opacity of the video overlay (0.0 to 1.0).</p> <code>1.0</code> <code>**kwargs</code> <p>Additional keyword arguments for the ipyleaflet.VideoOverlay layer.</p> <code>{}</code> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the bounds are not provided.</p> Source code in <code>gtlparser/gtlparser.py</code> <pre><code>def add_video(self, video, bounds=None, opacity=1.0, **kwargs):\n    \"\"\"Adds a video overlay to the map.\n\n    Args:\n        video (str): Path to the video file.\n        bounds (list): Bounds of the video in the format [[lat1, lon1], [lat2, lon2]].\n        opacity (float): Opacity of the video overlay (0.0 to 1.0).\n        **kwargs: Additional keyword arguments for the ipyleaflet.VideoOverlay layer.\n\n    Raises:\n        ValueError: If the bounds are not provided.\n    \"\"\"\n    from ipyleaflet import VideoOverlay\n\n    if bounds is None:\n        bounds = [[-90, -180], [90, 180]]\n    layer = VideoOverlay(url=video, bounds=bounds, opacity=opacity, **kwargs)\n    self.add(layer)\n</code></pre>"},{"location":"gtlparser/#gtlparser.gtlparser.Map.add_widget","title":"<code>add_widget(self, widget, position='topright', **kwargs)</code>","text":"<p>Adds a widget to the map.</p> <p>Parameters:</p> Name Type Description Default <code>widget</code> <code>ipywidgets.Widget</code> <p>The widget to be added to the map.</p> required <code>position</code> <code>str</code> <p>Position of the widget on the map. Options: 'topleft', 'topright', 'bottomleft', 'bottomright'.</p> <code>'topright'</code> <code>**kwargs</code> <p>Additional keyword arguments for ipyleaflet.WidgetControl.</p> <code>{}</code> Source code in <code>gtlparser/gtlparser.py</code> <pre><code>def add_widget(self, widget, position=\"topright\", **kwargs):\n    \"\"\"\n    Adds a widget to the map.\n\n    Args:\n        widget (ipywidgets.Widget): The widget to be added to the map.\n        position (str): Position of the widget on the map.\n            Options: 'topleft', 'topright', 'bottomleft', 'bottomright'.\n        **kwargs: Additional keyword arguments for ipyleaflet.WidgetControl.\n    \"\"\"\n    control = ipyleaflet.WidgetControl(widget=widget, position=position, **kwargs)\n    self.add(control)\n</code></pre>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#stable-release","title":"Stable release","text":"<p>To install gtlparser, run this command in your terminal:</p> <pre><code>pip install gtlparser\n</code></pre> <p>This is the preferred method to install gtlparser, as it will always install the most recent stable release.</p> <p>If you don't have pip installed, this Python installation guide can guide you through the process.</p>"},{"location":"installation/#from-sources","title":"From sources","text":"<p>To install gtlparser from sources, run this command in your terminal:</p> <pre><code>pip install git+https://github.com/GGweelplay/gtlparser\n</code></pre>"},{"location":"installation/#dependencies","title":"Dependencies","text":"<ul> <li>geopandas: A library for working with geospatial data in Python, built on top of pandas and shapely.</li> <li>json: Python's built-in library for working with JSON data.</li> <li>pandas: A powerful data manipulation and analysis library.</li> <li>Please ensure you have a compatible Python environment installed (Python 3.6 or higher recommended). The dependencies will be automatically installed when you use pip, but you may need to install system-level dependencies for geopandas (such as GDAL, GEOS, and PROJ) depending on your operating system. Consult the geopandas installation documentation for more details if you encounter issues.</li> </ul>"},{"location":"usage/","title":"Usage","text":"<p>To use gtlparser in a project:</p> <pre><code>import gtlparser\n</code></pre>"},{"location":"examples/Lab9/","title":"Lab9","text":"In\u00a0[1]: Copied! <pre>import gtlparser\n</pre> import gtlparser In\u00a0[2]: Copied! <pre>map1 = gtlparser.Map()\nmap1.add_basemap_gui(position=\"topright\")\nmap1.add_layer_control()\nmap1.add_search_control(position=\"topleft\")\nmap1\n</pre> map1 = gtlparser.Map() map1.add_basemap_gui(position=\"topright\") map1.add_layer_control() map1.add_search_control(position=\"topleft\") map1 Out[2]: In\u00a0[3]: Copied! <pre>import leafmap\n\nmap2 = leafmap.Map()\n\nwms_url = \"https://services.terrascope.be/wms/v2?\"\nlayer_name = \"WORLDCOVER_2021_MAP\"\n\nmap2.add_wms_layer(\n    url=wms_url,\n    layers=layer_name,\n    name=\"ESA World Cover 2021\",\n    format=\"image/png\",\n    transparent=True,\n    shown=True,\n    version=\"1.3.0\",\n)\n\nmap2.add_legend(builtin_legend=\"ESA_WorldCover\")\nmap2\n</pre> import leafmap  map2 = leafmap.Map()  wms_url = \"https://services.terrascope.be/wms/v2?\" layer_name = \"WORLDCOVER_2021_MAP\"  map2.add_wms_layer(     url=wms_url,     layers=layer_name,     name=\"ESA World Cover 2021\",     format=\"image/png\",     transparent=True,     shown=True,     version=\"1.3.0\", )  map2.add_legend(builtin_legend=\"ESA_WorldCover\") map2 Out[3]: In\u00a0[4]: Copied! <pre>import leafmap\nimport geopandas as gpd\nimport pandas as pd  # geopandas relies on pandas\n\ngeojson_url = \"https://github.com/opengeos/datasets/releases/download/places/wa_building_centroids.geojson\"\n\ngdf = gpd.read_file(geojson_url)\n\ngdf\ngdf[\"longitude\"] = gdf.geometry.x\ngdf[\"latitude\"] = gdf.geometry.y\n\n\nmap3_1 = leafmap.Map()\nmap3_1.add_marker_cluster(gdf, x=\"longitude\", y=\"latitude\", layer_name=\"World cities\")\nmap3_1\n</pre> import leafmap import geopandas as gpd import pandas as pd  # geopandas relies on pandas  geojson_url = \"https://github.com/opengeos/datasets/releases/download/places/wa_building_centroids.geojson\"  gdf = gpd.read_file(geojson_url)  gdf gdf[\"longitude\"] = gdf.geometry.x gdf[\"latitude\"] = gdf.geometry.y   map3_1 = leafmap.Map() map3_1.add_marker_cluster(gdf, x=\"longitude\", y=\"latitude\", layer_name=\"World cities\") map3_1 Out[4]: In\u00a0[5]: Copied! <pre>map3_2 = leafmap.Map()\nmap3_2.add_circle_markers_from_xy(\n    gdf,\n    x=\"longitude\",\n    y=\"latitude\",\n    radius=5,\n    color=\"red\",\n    fill_color=\"yellow\",\n    fill_opacity=0.8,\n    marker_cluster=True,\n)\nmap3_2\n</pre> map3_2 = leafmap.Map() map3_2.add_circle_markers_from_xy(     gdf,     x=\"longitude\",     y=\"latitude\",     radius=5,     color=\"red\",     fill_color=\"yellow\",     fill_opacity=0.8,     marker_cluster=True, ) map3_2 Out[5]: In\u00a0[6]: Copied! <pre>geojson_url = \"https://github.com/opengeos/datasets/releases/download/places/wa_overture_buildings.geojson\"\n\nmap4_1 = leafmap.Map()\n\ngeojson_style = {\n    \"color\": \"red\",\n    \"weight\": 2,\n    \"fillOpacity\": 0,\n}\n\nmap4_1.add_geojson(geojson_url, style=geojson_style, layer_name=\"Washington Buildings\")\n\nmap4_1\n</pre> geojson_url = \"https://github.com/opengeos/datasets/releases/download/places/wa_overture_buildings.geojson\"  map4_1 = leafmap.Map()  geojson_style = {     \"color\": \"red\",     \"weight\": 2,     \"fillOpacity\": 0, }  map4_1.add_geojson(geojson_url, style=geojson_style, layer_name=\"Washington Buildings\")  map4_1 Out[6]: In\u00a0[7]: Copied! <pre>geojson_url = \"https://github.com/opengeos/datasets/releases/download/places/las_vegas_roads.geojson\"\n\nmap4_2 = leafmap.Map()\n\ngeojson_style = {\n    \"color\": \"red\",\n    \"weight\": 2,\n}\n\nmap4_2.add_geojson(geojson_url, style=geojson_style, layer_name=\"Las Vegas Roads\")\n\nmap4_2\n</pre> geojson_url = \"https://github.com/opengeos/datasets/releases/download/places/las_vegas_roads.geojson\"  map4_2 = leafmap.Map()  geojson_style = {     \"color\": \"red\",     \"weight\": 2, }  map4_2.add_geojson(geojson_url, style=geojson_style, layer_name=\"Las Vegas Roads\")  map4_2 Out[7]: In\u00a0[8]: Copied! <pre>map4_3_data = (\n    \"https://github.com/opengeos/datasets/releases/download/us/us_counties.geojson\"\n)\n\nmap4_3 = leafmap.Map(center=(40, -98), zoom=4)\n\nmap4_3.add_data(\n    map4_3_data,\n    layer_name=\"US County Area (Census)\",\n    column=\"CENSUSAREA\",\n    scheme=\"EqualInterval\",\n    cmap=\"Blues\",\n    legend=True,\n    legend_title=\"Census Area (sq mi)\",\n)\n\nmap4_3\n</pre> map4_3_data = (     \"https://github.com/opengeos/datasets/releases/download/us/us_counties.geojson\" )  map4_3 = leafmap.Map(center=(40, -98), zoom=4)  map4_3.add_data(     map4_3_data,     layer_name=\"US County Area (Census)\",     column=\"CENSUSAREA\",     scheme=\"EqualInterval\",     cmap=\"Blues\",     legend=True,     legend_title=\"Census Area (sq mi)\", )  map4_3 Out[8]: In\u00a0[9]: Copied! <pre>pre_event_url = (\n    \"https://github.com/opengeos/datasets/releases/download/raster/Libya-2023-07-01.tif\"\n)\npost_event_url = (\n    \"https://github.com/opengeos/datasets/releases/download/raster/Libya-2023-09-13.tif\"\n)\n\nmap5 = leafmap.Map()\n\nleafmap.split_map(left_layer=pre_event_url, right_layer=post_event_url)\n\nmap5\n</pre> pre_event_url = (     \"https://github.com/opengeos/datasets/releases/download/raster/Libya-2023-07-01.tif\" ) post_event_url = (     \"https://github.com/opengeos/datasets/releases/download/raster/Libya-2023-09-13.tif\" )  map5 = leafmap.Map()  leafmap.split_map(left_layer=pre_event_url, right_layer=post_event_url)  map5 Out[9]:"},{"location":"examples/Lab9/#question-1-creating-an-interactive-map","title":"Question 1: Creating an Interactive Map\u00b6","text":""},{"location":"examples/Lab9/#question-2-adding-map-legends","title":"Question 2: Adding Map Legends\u00b6","text":""},{"location":"examples/Lab9/#question-3-creating-marker-clusters","title":"Question 3: Creating Marker Clusters\u00b6","text":""},{"location":"examples/Lab9/#question-4-visualizing-vector-data","title":"Question 4: Visualizing Vector Data\u00b6","text":""},{"location":"examples/Lab9/#question-5-creating-a-split-map","title":"Question 5: Creating a Split Map\u00b6","text":""},{"location":"examples/basemap/","title":"Basemap","text":"In\u00a0[1]: Copied! <pre>import gtlparser\n</pre> import gtlparser In\u00a0[2]: Copied! <pre>cool_map = gtlparser.Map()\n</pre> cool_map = gtlparser.Map() In\u00a0[3]: Copied! <pre>cool_map.add_basemap_gui(position=\"topright\")\ncool_map.add_layer_control()\n</pre> cool_map.add_basemap_gui(position=\"topright\") cool_map.add_layer_control() In\u00a0[4]: Copied! <pre>cool_map\n</pre> cool_map Out[4]:"},{"location":"examples/foliumap/","title":"Foliumap","text":"In\u00a0[1]: Copied! <pre>import gtlparser\nfrom gtlparser import foliumap\n</pre> import gtlparser from gtlparser import foliumap In\u00a0[2]: Copied! <pre>cool_map = foliumap.Map()\n</pre> cool_map = foliumap.Map() In\u00a0[3]: Copied! <pre>cool_map.add_basemap(basemap=\"Cartodb Positron\")\ncool_map.add_basemap(basemap=\"OpenStreetMap\")\n</pre> cool_map.add_basemap(basemap=\"Cartodb Positron\") cool_map.add_basemap(basemap=\"OpenStreetMap\") In\u00a0[4]: Copied! <pre>cool_map.add_vector(\n    \"https://github.com/opengeos/datasets/releases/download/world/countries.geojson\"\n)\n</pre> cool_map.add_vector(     \"https://github.com/opengeos/datasets/releases/download/world/countries.geojson\" ) In\u00a0[5]: Copied! <pre>cool_map.add_layer_control()\n</pre> cool_map.add_layer_control() In\u00a0[6]: Copied! <pre>cool_map\n</pre> cool_map Out[6]: Make this Notebook Trusted to load map: File -&gt; Trust Notebook In\u00a0[7]: Copied! <pre>m = foliumap.Map(height=600, location=[39.4948, -108.5492], zoom_start=10)\nm.add_split_map()\nm\n</pre> m = foliumap.Map(height=600, location=[39.4948, -108.5492], zoom_start=10) m.add_split_map() m Out[7]: Make this Notebook Trusted to load map: File -&gt; Trust Notebook"},{"location":"examples/foliumap/#folium-demo","title":"Folium Demo\u00b6","text":""},{"location":"examples/gtl2geojson/","title":"Gtl2geojson","text":"In\u00a0[1]: Copied! <pre>import gtlparser\nfrom gtlparser import gtl2geojson\n</pre> import gtlparser from gtlparser import gtl2geojson In\u00a0[2]: Copied! <pre>in_json = \"https://raw.githubusercontent.com/GGweelplay/gtlparser/main/docs/examples/example_timeline.json\"\n</pre> in_json = \"https://raw.githubusercontent.com/GGweelplay/gtlparser/main/docs/examples/example_timeline.json\" In\u00a0[3]: Copied! <pre>point_features = gtl2geojson.parse_visitPoint(in_json, flag_allField=1)\nline_features = gtl2geojson.parse_timelinePath(in_json)\n</pre> point_features = gtl2geojson.parse_visitPoint(in_json, flag_allField=1) line_features = gtl2geojson.parse_timelinePath(in_json) In\u00a0[4]: Copied! <pre>gtl2geojson.create_geojson_file(\".\", \"visit_points\", point_features, flag_point=True)\ngtl2geojson.create_geojson_file(\".\", \"timeline_path\", line_features, flag_point=False)\n</pre> gtl2geojson.create_geojson_file(\".\", \"visit_points\", point_features, flag_point=True) gtl2geojson.create_geojson_file(\".\", \"timeline_path\", line_features, flag_point=False) In\u00a0[5]: Copied! <pre>Map1 = gtlparser.Map(center=(0, 0), zoom=2, scroll_wheel_zoom=True)\n\nMap1.add_geojson(\n    data=\"https://raw.githubusercontent.com/GGweelplay/gtlparser/main/docs/examples/example_point.geojson\"\n)\nMap1.add_layer_control()\nMap1\n</pre> Map1 = gtlparser.Map(center=(0, 0), zoom=2, scroll_wheel_zoom=True)  Map1.add_geojson(     data=\"https://raw.githubusercontent.com/GGweelplay/gtlparser/main/docs/examples/example_point.geojson\" ) Map1.add_layer_control() Map1 <pre>Point\n{'radius': 5, 'color': 'blue', 'fillColor': '#3388ff', 'fillOpacity': 0.8, 'weight': 1} {'fillColor': 'red', 'fillOpacity': 1}\n</pre> Out[5]: In\u00a0[6]: Copied! <pre>Map2 = gtlparser.Map(center=(0, 0), zoom=2, scroll_wheel_zoom=True)\n\nMap2.add_geojson(\n    data=\"https://raw.githubusercontent.com/GGweelplay/gtlparser/main/docs/examples/example_line.geojson\"\n)\nMap2.add_layer_control()\nMap2\n</pre> Map2 = gtlparser.Map(center=(0, 0), zoom=2, scroll_wheel_zoom=True)  Map2.add_geojson(     data=\"https://raw.githubusercontent.com/GGweelplay/gtlparser/main/docs/examples/example_line.geojson\" ) Map2.add_layer_control() Map2 <pre>LineString\n{'color': 'blue', 'weight': 3, 'opacity': 0.8} {'color': 'yellow', 'weight': 4, 'opacity': 1}\n</pre> Out[6]:"},{"location":"examples/gtl2geojson/#read-google-timeline-data-from-json-and-convert-it-to-geojson-file","title":"Read Google Timeline data From JSON and Convert it to GeoJSON file\u00b6","text":""},{"location":"examples/intro/","title":"Intro","text":"In\u00a0[1]: Copied! <pre>import gtlparser\n</pre> import gtlparser In\u00a0[2]: Copied! <pre>gtlparser.__version__\n</pre> gtlparser.__version__ Out[2]: <pre>'0.2.0'</pre> In\u00a0[3]: Copied! <pre>import gtlparser\n</pre> import gtlparser In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/map/","title":"Map","text":"In\u00a0[1]: Copied! <pre>import gtlparser\n</pre> import gtlparser In\u00a0[2]: Copied! <pre>cool_map = gtlparser.Map()\n</pre> cool_map = gtlparser.Map() In\u00a0[3]: Copied! <pre>cool_map.add_basemap(basemap=\"OpenStreetMap\")\n</pre> cool_map.add_basemap(basemap=\"OpenStreetMap\") In\u00a0[4]: Copied! <pre>cool_map.add_google_maps()\n</pre> cool_map.add_google_maps() In\u00a0[5]: Copied! <pre>cool_map.add_vector(\n    \"https://github.com/opengeos/datasets/releases/download/world/countries.geojson\"\n)\n</pre> cool_map.add_vector(     \"https://github.com/opengeos/datasets/releases/download/world/countries.geojson\" ) <pre>Polygon\n{'color': 'blue', 'fillOpacity': 0.5} {'color': 'yellow', 'fillOpacity': 0.2}\n</pre> In\u00a0[6]: Copied! <pre>cool_map.add_layer_control()\n</pre> cool_map.add_layer_control() In\u00a0[7]: Copied! <pre>cool_map.add_raster(\n    filepath=\"https://github.com/opengeos/data/releases/download/raster/Libya-2023-07-01.tif\"\n)\n</pre> cool_map.add_raster(     filepath=\"https://github.com/opengeos/data/releases/download/raster/Libya-2023-07-01.tif\" ) In\u00a0[8]: Copied! <pre>img_path = \"https://cattime.com/wp-content/uploads/sites/14/2011/12/GettyImages-1361394182-e1699287824483.jpg?w=1024\"\nbounds = [20.0, 10.0, 30.0, 40.0]\ncool_map.add_image(image=img_path, bounds=bounds, opacity=0.5)\n</pre> img_path = \"https://cattime.com/wp-content/uploads/sites/14/2011/12/GettyImages-1361394182-e1699287824483.jpg?w=1024\" bounds = [20.0, 10.0, 30.0, 40.0] cool_map.add_image(image=img_path, bounds=bounds, opacity=0.5) In\u00a0[9]: Copied! <pre>cool_map.add_video(\n    video=\"https://www.mapbox.com/bites/00188/patricia_nasa.webm\",\n    bounds=((13, -130), (32, -100)),\n)\n</pre> cool_map.add_video(     video=\"https://www.mapbox.com/bites/00188/patricia_nasa.webm\",     bounds=((13, -130), (32, -100)), ) In\u00a0[10]: Copied! <pre>WMS_url = \"https://imagery.nationalmap.gov/arcgis/services/USGSNAIPPlus/ImageServer/WMSServer?\"\nlayer_name = \"USGSNAIPPlus:NaturalColor\"\ncool_map.add_WMS_layer(\n    WMS_url, layer_name, name=\"new_WMS_layer\", format=\"image/png\", transparent=True\n)\n</pre> WMS_url = \"https://imagery.nationalmap.gov/arcgis/services/USGSNAIPPlus/ImageServer/WMSServer?\" layer_name = \"USGSNAIPPlus:NaturalColor\" cool_map.add_WMS_layer(     WMS_url, layer_name, name=\"new_WMS_layer\", format=\"image/png\", transparent=True ) In\u00a0[11]: Copied! <pre># Show the map\ncool_map\n</pre> # Show the map cool_map Out[11]:"},{"location":"examples/map/#create-interactive-maps","title":"Create interactive maps\u00b6","text":""}]}